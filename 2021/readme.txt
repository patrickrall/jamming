
Core libraries:
    OpenGl, bound to python via PyOpenGl. 
        Docs: functions look identical to C, just use standard references on khronos.org.
        Or, just use QuadArray and TextBox libraries.
    glfw, bound to python via ctypes
        Docs: https://www.glfw.org/docs/latest/
        To see how the function names changed in the python version:
        https://github.com/FlorianRhiem/pyGLFW/blob/master/glfw/__init__.py
        To see how I bound this to the listen library: patpygl/listen.py




patpygl:
    To initialize:
    $ cd patpygl_devel
    $ pip install -e .

    Overview:
    listen.py - an event library supporting 'waiting for an event'
    vector.py - provides Vec(), a simple vector class
    projection.py - some convenient matrices like scale(x,y,z), translate(x,y,z)
    animator.py -  provides Animator(), an animation queue class
    quadarray.py - provides QuadArray(), which can draw a bunch of quads all at once
    textbox.py - provides TextBox(), handles drawing text
    node.py - a layout system, documentation is TODO, not so useful for games

    listen.py
        # Launching a listener:
        listen.launch(my_loop())

        # Dispatching an event:
        listen.dispatch("my_event_name",arg1,arg2)
            
        # Listening for an event:
        _, arg1,arg2 = yield from listen.event("my_event_name")

        # Listening for multiple events at once:
        events = yield from listen.any(
              event1 = listen.event("event1"),
              event2 = listen.event("event2"),
            )
        if "event1" in events: 
            _, arg1, arg2 = events["event1"]

        # Waiting for some time in seconds
        _, dt = yield from listen.wait(0.5)

        # Responding to glfw events
        _,x,y = yield from listen.on_cursor_pos(my_glfw_window)

    vector.py
        class Vec()
        # Stores a vector (floats by default) of any dimension.
        # Supports arithmetic, indexing, iteration, etc.
        # Swizzling - a convenient method for morphing the vector
        x = Vec(1,2,3)
        y = x.yx0  # y is Vec(2,1,0)
        # Can also invoke via x.swizzle("xy"), and can also set:
        x.setswizzle("xy",Vec(1,0))
        
        # other methods:
        dot(x,y)

        cross(x,y) # must be 3-vector

        zeros(3)

    projection.py
        # Some convenience functions for working with homogeneous coordinates
        http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/

        # In short, this is a trick for doing non-linear transformations like
        # translations and perspective projections using matrix multiplication
        # by padding out 3-vectors with an extra entry.

        translate(1,2,3) or translate(Vec(1,2,3))
        scale(1,2,3) or scale(Vec(1,2,3)

        rotateX(theta), rotateY(theta), rotateZ(theta)

        ortho(l,r,b,t,n,f) # orthographic projection
        
        # swap the x and y entries.
        permutation("YXZW") 
        
        # perform x ->  and z -> -x
        permutation("ZY-XW") 

        # convenient function for setting matrix uniforms:
        set_uniform_matrix(my_shader, "my_uniform_name", scale(1,2,3))

    animator.py
        # convenient loading of a json spritesheet generated by
        # aseprite for example into a bunch of OpenGL textures.
        # See doc comment for details.
        frames, sheet = load_spritesheet(fname)
        
        # each frame is a dictionary, crucially with a "duration" key
        my_frame = {
            "duration": 0.1 # in seconds
            "texture": my_texture_or_whatever
        }

        # a class that maintains an animation queue of frames
        class Animator()

        x = Animator()

        x.clear() # clear the queue
        
        # enqueue some frames
        x.enqueue([my_frame,my_frame]) 

        # make it loop when it hits the end
        x.enqueue([my_frame,my_frame], loop=True)

        # make it have a label
        x.enqueue([my_frame,my_frame], label="my_label")

        # access properties of the current frame
        # will raise KeyError if queue is empty
        x["texture"]

        # get the current label, is None if queue is empty or unlabeled
        x.label

        # property
        x.paused = True

        # useful events, see doc strings for details
        yield from x.on_label_change()
        yield from x.on_change()
        yield from x.on_end()
        yield from x.on_loop()

    quadarray.py
        # make sure to call this as soon as you have your
        # OpenGl context - this compiles the shader.
        init_quadarray()
        
        # class that draws a bunch of quads, all with the same asset
        class QuadArray()
        
        # init with an Animator, a list of frames, or just a single frame dict
        quadarray = QuadArray([my_frame,my_frame])

        # make sure that each frame has a size key, for the size of the quad
        # furthermore, the frames should all be the same size.
        my_frame["size"] = Vec(width,height)

        # if you give it a list of frames it turns it into an Animator for you
        # either way, access with
        quadarray.asset["texture"]
        quadarray.asset.enqueue([my_frame],loop=True)

        # The list of quads, which is just a list of Vec3's
        quadarray.quads[0] = Vec(0,0,0)

        # The quads in OpenGL won't update until you call
        quadarray.update()
        
        # To draw:
        glUseProgram(QuadArray.quadshader) # load the shader
        set_uniform_matrix(QuadArray.quadshader, "projection", translate(x,y,z)) # set the projection
        quadarray.draw() # call the draw method
        
 
    textbox.py
        # call this once you have the OpenGL context, compiles the shader.
        # width and heigth specify the dimension of the glyph atlas
        # program will crash with an error message if this runs out of space
        init_textbox(w=1000,h=2000)  
        
        # class that draws some text at some location,
        # all with the same font face, size and color
        class TextBox()

        x = TextBox("IBMPlexSans-Regular.ttf")  
        # optional arguments:
        size=30, color=Vec(0,0,0), pos=Vec(0,0,0)

        # can also read and set via
        x.size, x.color, x.pos

        # can set font via
        x.font_face = "IBMPlexSans-Mono.ttf"

        # unlike QuadArray, this calls its own update function automatically

    node.py
        # TODO: docs for this.
        # not so important for games.


Platformer example:
    Overview:
    globs.py - an empty file. Everybody imports this and uses it to store global vars.
    main.py - initialization, game_loop, asset loading
    render.py - Draws globs.quadarrays and globs.textboxes every frame. Also viewport.
    edit.py - A simple grid editor. Provides Grid class, grid_editor_loop.
    play.py - Simple platformer physics and animations.

    main.py
        main():
            # this stuff is rendered every frame
            globs.quadarrays = []
            globs.textboxes = []
            
            # launches a bunch of other listeners


        game_loop():
            # A listener that dispatches "on_frame" and "on_render"
            # every single frame. Also maintains an fps meter.
        
        load_assets():
            # uses patpygl.animator.load_spritesheet to load the assets
            # populates frame["size"] key so QuadArray knows how big the quads are
            # assets whose names end in "-right" also get a "-left"
       

    render.py
        # assets are 16x16 pixels.
        # want each pixel to be 3x3 so it looks like pixel art
        # also want 16 pixels to correspond to 1 'unit' in model coordinate system
     
        render_init(w,h):
            # camera data is stored here
            globs.cam = {...}

        viewport_loop():
            # maintains globs.cam["projection"] when window is resized,
            # projection converts model coordinates into viewport coordinates

        mouse_coords(x,y):
            # convert mouse coordinates into model coordinates
       
        render_loop():
            # draws globs.quadarrays and globs.textboxes every frame.

    edit.py
        edit_init():
            globs.mode = "grid_edit" or "play"
            globs.grid = instance of Grid() class

        editor_camera_loop():
            # when in grid_edit mode, use wasd to adjust globs.cam["pos"]

        # maintains a bunch of quadarrays, one for each asset
        # put this in globs.grid
        class Grid():
            globs.grid.assets  # list of asset names in grid
            globs.save()       # save to disk
            globs.grid[0,0]                 # get 
            globs.grid[0,0] = "terrain-top" # set
            del globs.grid[0,0]             # delete

        grid_editor_loop():
            # when in grid_edit, implements GUI for grid editor.
            # cursor for currently selected asset
            # left click to place, right click to delete
            # scroll to change selection
            # middle click on a tile to eyedropper
            # middle click onto empty space to put player there

    play.py
        player_init():
            globs.playerarray = QuadArray() # array for rendering player

        place_player(x,y):
            # convenience for grid_editor_loop()

        escape_loop():
            # when in play mode, press escape to exit play mode

        dpad_loop():
            # keep Vec2() up to date with direction of WASD

        play_loop():
            # every frame, adjust player position
            # check if player is touching any geometry
            # compute new velocity given gravity, touching and dpad
            # move player with collision detection
            # depending on motion, adjust player asset
        
        squares_intersect(p1,p2):
            # do two 1x1 squares intersect?
            # right now all tiles and the player are 1x1
        
        split_delta(delta,pl):
            # splits delta into lots of little vectors
            # where the entries are about ~pl. 

        # intended usage of split_delta:
        for nudge in split_delta(delta, 0.01):
            any_collisions = check_collision(playerpos, ...)
            if any_collisions: break
            playerpos += nudge


Some exercises:
    Play with the velocity parameters to make the platforming 'feel better'
    Joystick support
    Sound effects
    Background assets with parallax
    Camera tracking (starseed pilgrim style?)
    Text box indicating play/edit mode
    Smarter grid editor
    Make the cursor quad move when the camera moves



